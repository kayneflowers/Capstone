// What does mixins do? It avoids writing media query over and over again.
/* 
    Provides a semantic media query from the following:
    Respond above XX(screen sizes)
    Respond below XX
    Respond between XX and XX

    Whereas:
    XX is the two letter bootstrap breakpoint (i.e sm, md)

    SYNTAX for media query
    @media (min-width: 768px) and (max-width: 991px) 
    {
        Target devices between 768px and 992px
    }

    It's best practice to use Bootstrap breakpoints in your own code but it's painful to write them all the time.  
*/

// Step 1: Identify the breakpoints
// LEGEND: Create a Sass variable to enumerate breakpoints
// NOTE: These breakpoints are customizable via SaSS

// rgb(108, 117, 125) "Main Color"

$breakpoints: (

    xs: 0,
    sm: 576px,
    md: 768px,
    lg: 992px,
    xl: 1200px,
    xxl: 1400px
);


:root {
    font-size: 16px;
}
//Default body
body{
    min-height: 100vh;
    display: grid;
    max-width: 100vw;
    grid-template-rows: auto 1fr auto;  /* key rule */
    grid-template-columns: 1fr;
    grid-template-areas: "header header" 
                           "section" 
                         "footer footer";
    >*  :not(header)
        :not(footer)
        :not(script)
        :not(link)
        :not(.leftSidebar)
        :not(.rightSidebar)
        :not(.card-body)
        :not(.banner1)
        :not(.accordion1)
    {
        display: flex;
        flex-wrap: wrap;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
}

// Embed
iframe{
    aspect-ratio: 16/9;
    width: 100%;
    height: 100%;
}

.grid_column_center{
    display: flex;
    flex-wrap: wrap;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
// *{
//     background-color: rgba(0, 255, 255, 0.288);
// }

*{
    margin: 0;
    padding: 0;
}

footer{
    margin-top: auto;
    margin-bottom: 0;
}

bg-transparent{
    background-color: transparent !important;
}


// Boxes

.card_title {
    font-size: 2rem;
    text-align: center;
    
}

.container {
    padding-top: 3%;
    padding-bottom: 3%;
    padding-left: 3%;
    padding-right: 3%;
    --bs-bg-opacity: 0.5;
    background-color:   rgba(var(--bs-secondary-bg-rgb),
                        var(--bs-bg-opacity))!important;
}

.center_box {
    display: flex;
    justify-content: center;
    align-items: center;
}

//Default banner
.slol {
    background-repeat: no-repeat;
    background-color: white;
    background-image: url("../images/wallpapers/Gray_White.svg");
    background-size: cover;
    font-size: 1.25rem;
}

// .slol1 {
//     height: 100vh;
//     width: 100%;
//     background-repeat: no-repeat;
//     background-color: white;
//     background-image: url("../images/wallpapers/Gray_White.svg");
//     background-size: cover;
//     display: flex;
//     justify-content: center;
//     align-items: center;
//     font-size: 1rem;
// }

.leftSidebar {
    display: flex;
    margin-right: auto;
    margin-left: 0;
    padding: 5px;
}

.mid-content {
    display: flex;
    padding: 5px;
}

.rightSidebar {
    display: flex;
    margin-left: auto;
    margin-right: 0;
    padding: 5px;
    color: white;
}

.sidebar-wrapper {
    width: 40%;
    float: left !important;
}

.content {
    display: flex;
    justify-content: start;
    padding: 0 20px;
}

.content-wrapper {
    width: 60%;
    float: left;
}

//Background

.carousel-control-next-icon , .carousel-control-prev-icon {
    background-color: rgba(108, 117, 125, 0.2);
    border-radius: 50%;
    box-shadow: 0 0 0 1px;
}


//Links

.list-group a, .pagination a {
    color: rgb(108, 117, 125);
    text-decoration: none !important;
}

.pagination .active {
    background-color: rgb(108, 117, 125);
    color: white;
    border-color: rgb(108, 117, 125);
}

.end-content a {
    background-color: rgb(108, 117, 125);
    color: white;
    border-color: rgb(108, 117, 125);
}

/* make it red instead (with with same width and style) */
*:active, *:hover {
    outline-color: rgb(108, 117, 125);
  }

.nav-link{
    padding-left: 5%;
}

.nav-link-f{
    padding-left: 0;
}

.contact-link {
    color: black;
    text-decoration: none;
}
  
.contact-link:hover {
    color: rgb(108, 117, 125);
    opacity: 1;
}

/* Style all font awesome icons */
.fa {
    padding: 6px;
    font-size: 20px;
    width: 30px;
    height: 30px;
    text-align: center;
    text-decoration: none;
}

/* Point Left */
.fa-hand-back-point-right {
    background: rgb(36, 36, 36);
    border-radius: 50%;
    color: white;
}

/* Add a hover effect if you want */
.fa:hover {
    color: black;
    opacity: 0.7;
}

/* Set a specific color for each brand */

/* Facebook */
.fa-facebook {
    background: rgb(108, 117, 125);
    border-radius: 50%;
    color: white;
}

/* Twitter */
.fa-twitter {
    background: rgb(108, 117, 125);
    border-radius: 50%;
    color: white;
}

/* Instagram */
.fa-instagram {
    background: rgb(108, 117, 125);
    border-radius: 50%;
    color: white;
}

/* Github */
.fa-github {
    background: rgb(108, 117, 125);
    border-radius: 50%;
    color: white;
}

/* LinkedIn */
.fa-linkedin {
    background: rgb(108, 117, 125);
    border-radius: 50%;
    color: white;
}

/* Fixes dropdown menus placed on the right side */
.me-auto .dropdown-menu {
    left: auto !important;
    right: 0px ;
}

.class-with-background1{
    background-image: url("../images/wallpapers/Gray_White.svg");
    background-size: contain;
}

.class-with-background2{
    background-image: url("../images/wallpapers/Gradient_White-Gray.svg");
    background-size: contain;
    background-color: gray;
}

// Step 2: Cerate the map values
// This means that breakpoints are only written once. Map values like these can be accessed using SaSS map-get function

$breakpoint: map-get($breakpoints , sm ); //Get the Small breakpoint.
$breakpoint: map-get($breakpoints , md );   //Get the Medium breakpoint.
$breakpoint: map-get($breakpoints , lg ); //Get the Large breakpoint.
$breakpoint: map-get($breakpoints , xl ); //Get the extra Large breakpoint.
$breakpoint: map-get($breakpoints , xxl ); //Get the extra extra Large breakpoint.

// Step 3: Create map-has-key function - it ensures that key exists within the $breakpoints map
@mixin respond-above ($breakpoint) {

    //If the breakpoint exists in the map
    @if map-has-key($breakpoints, $breakpoint )
    {
        //Declare a variable to get the breakpoint value
        $breakpoint-value:map-get($breakpoints , $breakpoint );
        //Write the media query
        @media (min-width: $breakpoint-value) {
            @content; 
        }

    } @else {
        //Log a warning
        @warn 'Invalid breakpoint: #{$breakpoint}.';
        //It displays a warning that a breakpoint doesn't exist in the map
    }
}


//To pass a value to the respond above mixin in the form of a bootstrap breakpoint

@include respond-above(sm) {
    .card {
        display: block;
    }
}

//Without this (@wanr), the media query won't show up in your compiled CSS and you'll have no idea.

@mixin respond-below ($breakpoint) {
    //If a breakpoint exists in the map
    @if map-has-key($breakpoints , $breakpoint ) {
        //Get the breakpoint value
        $breakpoint-value: map-has-key($breakpoints , $breakpoint );

        //Write the media query
        @media (max-width: ($breakpoint-value - 1))
        {
            @content; 
        }
    } @else {
        @warn 'Invalid breakpoint: #{$breakpoint}.';
    }
}

@include respond-below(lg)
{
    .card {
        display: block;
    }

    img {
        width:100%;
        height: auto
    }
}


/*
    Respond Between
    - it checks both lower and upper keys exists in the breakpoints before  writing this in the media query
    - we will check that both $lower and $upper keys exists in the $breakpoints map before writing it in the media query
*/

@mixin respond-between ($lower, $upper) {
    //Whereas: the variables above indicates that these are lower and upper breakpoints that are existing in the map.
    
    //Create a conditional statement where we will define that lower and upper breakopoints exist in the map
    @if map-has-key($breakpoints , $lower ) and map-has-key($breakpoints , $upper)
    {

        //Get the lower and upper breakpoints
        $lower-breakpoint:map-get($breakpoints , $lower );
        $upper-breakpoint:map-get($breakpoints , $upper );

        //Write the media query
        @media (min-width:$lower-breakpoint) and (max-width: ($upper-breakpoint - 1))
        {
            @content;
        }

        //If one or both of the breakpoints don't exist
    } @else {

        //If lower breakpoint is invalid.
        @if (map-has-key($breakpoints, $lower ) == false)
        {
            //log a warning
            @warn 'Invalid lower breakpoint: #{$lower}.';
        }

        @if (map-has-key($breakpoints , $upper ) == false)
        {
            //log a warning
            @warn 'Invalid upper breakpoint: #{$upper}.';
        }

    }
}

@include respond-between(sm,xxl ) {
    .card img {
        display: block;
        height: 100%;
    }

}



foot-top .navbar-nav{
    width: 100%;
    @include respond-between(xs,md){
        margin: 0 !important;
    }
}

@include respond-above(lg){
    .img-fluid{
        max-width: 90% !important;
        height: auto;
    }
} 


